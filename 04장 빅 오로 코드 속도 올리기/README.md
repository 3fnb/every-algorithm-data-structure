# 빅 오로 속도 올리기

빅 오는 알고리즘의 효율성을 알 수 있는 빠른 도구⚒  
`느린`알고리즘이라면, 더 빠른 빅 오 카테고리에 들어갈 수 있게 최적화 하는 방법을 찾아 볼 수 있다.

## 버블 정렬

컴공에서 호랑이 담배피던 시절부터 내려온 전통 고전 알고리즘이다.

정렬에 대한 알고리즘은 수십개가 있는데, 그 중 버블 정렬에 대해 공부해보자.  
(더 공부하고 싶다면 다음 키워드로 검색해보자 선택,삽입,버블,퀵,합병 (O^2 , nlogn) )

오름차순, 내림차순으로 정렬되지 않은 배열을 순서대로 정렬 시키려면 어떻게 해야할까?

버블 정렬의 경우 가장 큰 값 (버블)이 자기의 위치로 가게 되는 정렬 방법이다. (혹은, 바다에서 거품 두개가 엎치락 뒤치락 하며 수면 위로 떠오르는 이미지를 생각해도 비슷하다)

0. 오름차순으로 정렬할것이다.
1. 처음 두 수를 비교한다.
2. 만약 순서가 잘못되어 있다면(첫번째 수가 더 크다면), 바꾼다.
3. 두번째 수와 세번째 수를 비교한다.
4. 반복

최악의 경우를 생각해볼때 원소의 개수가 n인 경우 n번씩 반복을 n번 해야하는 O(n^2)의 시간 복잡도를 가진다. 이는 이차 시간 이라고도 부른다.

## 이차 문제

O(N^2)는 느린 알고리즘이다. 이걸 빠르게(O(N)) 바꾸려면 어떻게 해야 할까?

현실적인 예제를 소개하겠다.
[1,7,8,4,1]처럼 중복이 있는경우 true, [1,6,4] 와 같이 중복이 없는경우 false를 반환하는 함수.
이중 for문이 생각나지 않나?  
하지만 이중포문은 O(N^2) 더 나은 방법이 있지 않을까?

## 선형 해결법

1. 빈 배열을 만들어 준다.
2. 판단하고 싶은 배열의 길이만큼 for문을 돈다.
3. 판단하고 싶은 배열의 값을 빈 배열의 인덱스로, 값은 임의로 정한 고정된 값으로 넣어준다.
4. 만약, 고정된 값이 있을시 true 반환

```javascript
const hasDuplicateValue(arr) => {
  let existingNumbers = [];
  for(let i=0; i<arr.length; i++){
    if(existingNumbers[arr[i]]===1) return true
    else existingNumbers[arr[i]] =1;
  }
  return false;
}
```
