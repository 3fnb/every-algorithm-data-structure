# 동적 프로그래밍

재귀는 확실히 문제를 해결할 수 있어도, 신경써서 사용하지 않는다면 느려질 수 있다.

## 불필요한 재귀 호출

책에서 예시로 들은함수는 배열에서 최댓값을 찾는 함수이다.  
조건문 안에서 재귀호출로 최대값인지 비교하고, 최대값이라면 바로 리턴, 최대값이 아니라면, 조건문 안에서 실행했던 재귀호출을 사용해 최대값을 반환한다.

딱 봐도 재귀 호출을 두번씩 쓰는경우 ... 이럴경우 변수를 활용해 어딘가에 저장해놓고, 재활용하면 좋다.

## 하위 문제 중첩

피보나치 수열은 재귀와 동적프로그래밍을 논할때 빠지지 않는 주제이다.  
점화식 자체가 재귀를 두번 더한것이기 때문이다.  
이렇듯 재귀를 두번 더하는것을 하위문제 중첩이라고 부른다.  
이것은 결국 2^n의 시간복잡도를 가져가기때문에 개선하면 좋겠지만, 피보자치 수열 자체의 점화식이 애초에 재귀를 두번 더한것이기에 떠올려내기 쉽지 않다.  
한번 같이 해결해보자

## 메모이제이션

어딘가에 저장한다.  
피보나치 수열로 구한 값을 해쉬테이블에 저장한다.  
만약 해쉬테이블에 존재하지 않는다면 피보나치 수열을 계산한다.  
위와 같은 논리로 식을 만들면 해결이다.  
O(N)이기에 빠른 속도를 보장하지만 해쉬테이블을 사용하기때문에 공간을 더 쓴다.

## (상향식) 동적 프로그래밍

상향식은, 같은 문제를 재귀 대신 루프같은 다른 방식으로 해결한다는 말이다.  
상향식이기 때문에 제일 바닥, 첫번째 항부터 시작하고, 어디엔가 피보나치 수열을 저장한다.

1. 기저조건은 0이다. 0이 들어오면 0을 리턴한다.
2. 반복문을 돌려 피보나치 수열을 계산한다. 반복문 안에서는 첫번째항, 둘째항, 임시값을 사용해 두 수를 더해준다.

O(N)이고 공간을 추가로 사용하지 않는다.  
다만 로직을 한번에 딱 쉽게 이해할 수 있도록 점화식이 드러나있지 않다.

## 마무리

동적프로그맹은 크게 두가지로 쓸 수 있다.  
메모이제이션, (상향식 동적 프로그래밍).
피보나치를 구현한 위 예제를 노션에 첨부한다.

https://www.notion.so/wecode/2-3d67520096aa4f85a34c704cc6847442
