# 재귀적으로 작성하는 법

재귀적으로 작성하는법을 익히기 쉽도록, 카테고리를 나누어 설명하겠다.
반복실행 (추가 인자 넘기기), 계산, 하향식 재귀, 마지막으로 두개의 예제를 보면서 재귀를 더 잘 알아가보자!

<br>

## 1. 반복 실행

반복적으로 **한 작업을 반복하는것을** 재귀로 만들어보자.  
핵심은 작업을 반복실행하는것이다.  
10부터 0까지 차례로 콘솔을 출력해야한다던지, 한 디렉토리에 대한 하위 파일명, 디렉토리명의 나열이라던지 반복적인 작업에 유용한다.  
그런데 ... 만약 배열을 받아 배열에 있는 요소들을 두배로 만들어 반환시키는 함수를 만든다고 한다면  
배열 요소를 순회 해야 하는데, 반복문에서 쉽게 넣어주었던 인덱스를 재귀에서는 어떻게 넣을까 고민이다.  
이럴때 두번째 인자로 index를 넘겨주어 해결할 수 있다.

```jsx
const doubleArray = (array, index = 0) => {
  if (index >= array.length) return;

  array[index] *= 2;
  doubleArray(array, index + 1);
};
```

위와같이 default parameter를 이용하면 더 깔끔하게 처리가 가능하다.

<br>

## 2. 계산

핵심은 **하위문제**에 기반한 계산 수행하기이다.  
6! = 6 X 5 X 4 X 3 X 2 X 1  
6! = 6 X 5!  
여기서 6!의 하위문제는 5!이다.

<br>

더 알아보기전에 한가지 패러다임을 알고 넘어가길 원한다.
상향식, 하향식이란 말이있다. 바텀업, 탑다운  
하향식은 큰 문제에서 하위 문제로 쪼개서 들어가는 위에서 내려오는 방식,  
상향식은 밑에서부터 하나씩 생각하면서 올라가는 방식이다.  
팩토리얼 문제로 예를 들자면,

1. 상향식

```jsx
const factorial = (n, i = 1, product = 1) => {
  if (i > n) return product;
  return factorial(n, i + 1, product * i);
};
```

2. 하향식

```jsx
const factorial = num => {
  if (num === 1) return 1;
  else return num * factorial(num - 1);
};
```

상향식이든, 하향식이든 둘다 재귀로 문제를 풀 수 있다는점은 같지만 상향식은 루프에 비해 그다지 장점이 있어보이진 않는다.  
하향식 방식을 구현하기위해선 재귀가 필수적이며 이때문에 재귀가 강력한 도구가 된다.

<br>

## 하향식 재귀

문제를 해결하는 새로운 사고 전략이다.

1. 작성중인 재귀함수를 누군가 구현해놓았다고 생각을 한다.
2. 하위 문제를 찾는다.
3. 하위문제에 함수를 호출하면 어떻게 될지 생각한다.

위의 단계를 따라가면 하향식 재귀를 쉽게 적용할 수 있다.

<br>

### 배열의 합

배열의 모든 수를 합하는 sum 함수를 작성한다.  
[1,2,3,4,5]를 전달하면 15가 나오는 방식.

1. sum 함수를 누군가 작성해놨다고 생각한다.
2. 0번 인덱스에 대한 하위문제는 [2,3,4,5] 이다.
3. 하위문제에 대한 함수를 호출할 경우, 반환값은 array[0] + sum(array[1,array.length-1])이다.
4. 기저조건은 배열의 길이가 1이 될 경우
5. 문제 해결

<br>

### 문자열 뒤집기

"abcde"를 입력하면 "edcba"가 나오도록 하자.

1. reverse 함수를 누군가 작성해놨다고 생각한다.
2. 0번 인덱스에 대한 하위문제는 "bcde"이다.
3. 함수의 리턴값은 reverse(string[1,length-1]) + string[0]
4. 기저조건은 길이가 1인 스트링이 되었을때 이다.
5. 문제 해결

### X세기

"axbxcx"를 입력하면 3이 나오도록 하자.

1. countX가 있다고 가정
2. 하위문제는 "xbxcx"
3. 리턴값은 첫번째 인덱스가 x라면 1을 더해주고, 아니라면 하위문제의 함수 리턴
4. 기저조건은 length가 1이 될 때

### 계단문제

계단의 숫자가 주어지고, 올라갈 수 있는 경우의 수를 구하는 문제이다. 단 한번에 올라갈수 있는 계단의 수는 1, 2, 3 이다.

1. 상향식으로 접근한다면 일단 모든 경우의 수를 세고, 그에 따른 코드를 작성한다.  
   쉽지 않은 길이다.

2. 하향식으로 작성한다면 아래와 같이 사고한다.

1) 11짜리 계단이라면 하위문제는 10계단이다.
2) 이것을 통해 11짜리 계단의 경우의 수를 다 알수는 없다. 왜냐하면 계단을 한칸씩만 올라가는것이 아니라 두칸 세칸씩도 올라갈 수 있기 때문이다.
3) 조금 더 생각해보자면, 11짜리 계단까지 한번에 올라갈수 있는 경우의 수인 10짜리,9짜리,8짜리의 합이 11짜리 계단이다.
4) 따라서 점화식은 an(n-1) + an(n-2) + an(n-3)이다.

기저조건도 하나씩 접근해보면 해결할 수 있다.  
an(0) = 0  
an(1) = 1  
an(2) = 2  
an(3) = 4  
이렇게만 써도 맞지만, 경우의 수를 더 생각해보면  
n<0 일때 0  
n===1, n===0 일때 1
로 처리하면 해결할 수 있다.

### 에너그램

애너그램이란, 주어진 문자열에 대한 모든 문자 조합이다.  
이것을 재귀로 푼다고 생각하면 우리가 익숙하게 풀어왔던 방식대로 하면 된다.

1. 이미 존재하는 함수 makeAnagram
2. abc의 하위문제는 bc
3. 리턴값은, 모든 경우의 수를 생각해주어야 하기 때문에 안에서 루프를 돌려 해결해준다.

에너그램의 경우, 글자수에 따라 팩토리얼로 경우의 수가 증가한다. 지금까지 본적없는 빅오 단계로 factorial time이라고 부른다.

<br>
